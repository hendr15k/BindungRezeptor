import pandas as pd
from rdkit import Chem
from rdkit.Chem import Descriptors
import m2cgen as m2c
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score
import numpy as np

def calculate_descriptors(smiles):
    try:
        mol = Chem.MolFromSmiles(smiles)
        if not mol:
            return None
        # We use descriptors that are available via PubChem API or easy to calculate
        # PubChem returns: MolecularWeight, XLogP, TPSA, HBondDonorCount, HBondAcceptorCount, RotatableBondCount
        # RDKit equivalents:
        mw = Descriptors.MolWt(mol)
        logp = Descriptors.MolLogP(mol)
        tpsa = Descriptors.TPSA(mol)
        hbd = Descriptors.NumHDonors(mol)
        hba = Descriptors.NumHAcceptors(mol)
        rot_bonds = Descriptors.NumRotatableBonds(mol)

        return [mw, logp, tpsa, hbd, hba, rot_bonds]
    except Exception as e:
        return None

def train():
    print("Loading data...")
    df = pd.read_csv('data/chembl_raw.csv')

    X = []
    y = []

    print("Calculating descriptors...")
    for idx, row in df.iterrows():
        desc = calculate_descriptors(row['SMILES'])
        if desc:
            X.append(desc)
            y.append(row['Target'])

    print(f"Valid samples: {len(X)}")

    X = np.array(X)
    y = np.array(y)

    # Train/Test split
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

    print("Training Random Forest...")
    # Keep max_depth small to reduce JS file size
    clf = RandomForestClassifier(n_estimators=50, max_depth=7, random_state=42)
    clf.fit(X_train, y_train)

    y_pred = clf.predict(X_test)
    acc = accuracy_score(y_test, y_pred)
    print(f"Test Accuracy: {acc:.2f}")

    print("Exporting model to JS...")
    code = m2c.export_to_javascript(clf, function_name="predictClass")

    # Wrapper for probability handling if m2cgen supports it?
    # m2cgen export_to_javascript for Classifier returns a score array usually.
    # Actually for sklearn RF classifier, m2cgen returns the class scores/probabilities.
    # Let's verify what it returns. Usually it generates a function `predictClass(input)` that returns an array of scores.
    # We need to map these scores back to class names.

    classes = clf.classes_
    print(f"Classes: {classes}")

    # Append a helper function to JS to map scores to class names
    # Ensure we serialize numpy strings to regular strings
    import json
    class_map_js = "const MODEL_CLASSES = " + json.dumps(classes.tolist()) + ";\n"

    with open('js/model.js', 'w') as f:
        f.write(code)
        f.write("\n\n")
        f.write(class_map_js)
        f.write("""
function predictWithModel(inputFeatures) {
    // predictClass is generated by m2cgen
    const scores = predictClass(inputFeatures);

    // Normalize scores to probabilities (if not already sum to 1? RF usually votes)
    // m2cgen for RF returns sum of votes (not normalized by n_estimators?) or normalized?
    // Let's assume normalized or we normalize.

    let sum = 0;
    for(let s of scores) sum += s;

    let results = [];
    for(let i=0; i<scores.length; i++) {
        results.push({
            name: MODEL_CLASSES[i],
            probability: scores[i] / sum
        });
    }

    results.sort((a,b) => b.probability - a.probability);
    return results;
}
""")

    print("Model saved to js/model.js")

if __name__ == "__main__":
    train()
